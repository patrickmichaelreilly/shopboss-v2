@{
    ViewData["Title"] = "Import Work Order";
}

@section Styles {
    <link rel="stylesheet" href="~/css/unified-tree.css" asp-append-version="true" />
    <style>
        .progress-container {
            background: #f8f9fa;
            border-radius: 0.5rem;
            padding: 1.5rem;
            border: 1px solid #dee2e6;
        }
        
        .stage-indicator {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            font-weight: 500;
        }
        
        .stage-indicator.active {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        
        .import-actions {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .selection-warnings {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 0.375rem;
            padding: 0.75rem;
            margin-bottom: 1rem;
        }
    </style>
}

<div class="row justify-content-center">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title mb-0">
                    <i class="fas fa-upload me-2"></i>Import Work Order
                </h3>
            </div>
            <div class="card-body">
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>
                    <strong>Important:</strong> The import process takes 2-3 minutes to complete. 
                    Please be patient and do not close this window during the import.
                </div>

                <!-- Step 1: File Upload -->
                <div id="uploadStep" class="step-content">
                    <div class="mb-4">
                        <h5>Select SDF File</h5>
                        <div class="mb-3">
                            <div id="dropZone" class="border border-2 border-dashed rounded p-4 text-center bg-light" style="min-height: 150px; cursor: pointer;">
                                <div class="d-flex flex-column align-items-center justify-content-center h-100">
                                    <i class="fas fa-cloud-upload-alt fa-3x text-muted mb-3"></i>
                                    <p class="mb-2"><strong>Drop your SDF file here</strong></p>
                                    <p class="text-muted mb-0">or click to browse</p>
                                </div>
                            </div>
                            <input type="file" id="sdfFile" accept=".sdf" class="d-none" required>
                            <div id="fileInfo" class="mt-2 d-none">
                                <div class="alert alert-success">
                                    <i class="fas fa-file-database me-2"></i>
                                    <span id="fileName"></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="d-grid gap-2">
                        <button type="button" id="startImportBtn" class="btn btn-primary btn-lg" disabled>
                            <i class="fas fa-play me-2"></i>Start Import Process
                        </button>
                        <a asp-action="Index" class="btn btn-secondary">
                            <i class="fas fa-arrow-left me-2"></i>Back to Work Orders
                        </a>
                    </div>
                </div>

                <!-- Step 2: Progress Tracking -->
                <div id="progressStep" class="step-content d-none">
                    <div class="progress-container">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5 class="mb-0">Import Progress</h5>
                            <button type="button" id="cancelImportBtn" class="btn btn-outline-danger btn-sm">
                                <i class="fas fa-times me-1"></i>Cancel
                            </button>
                        </div>
                        
                        <div class="progress mb-3" style="height: 20px;">
                            <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                                0%
                            </div>
                        </div>
                        
                        <div class="stage-indicator mb-3">
                            <i class="fas fa-spinner fa-spin me-2"></i>
                            <span id="currentStage">Preparing import...</span>
                        </div>
                        
                        <div class="text-muted">
                            <small>
                                <i class="fas fa-clock me-1"></i>
                                Estimated time remaining: <span id="timeRemaining">Calculating...</span>
                            </small>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Preview and Confirm -->
                <div id="previewStep" class="step-content d-none">
                    <div class="alert alert-success">
                        <i class="fas fa-check-circle me-2"></i>
                        <strong>Import Ready:</strong> Review the work order details below and make any necessary adjustments before importing.
                    </div>
                    
                    <!-- Work Order Metadata Section -->
                    <div class="mb-4">
                        <h5>Work Order Information</h5>
                        <div class="card">
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-md-6">
                                        <label for="finalWorkOrderName" class="form-label">Work Order Name</label>
                                        <input type="text" id="finalWorkOrderName" class="form-control" placeholder="Work Order Name">
                                        <small class="form-text text-muted">Edit the work order name if needed before importing.</small>
                                    </div>
                                    <div class="col-md-3">
                                        <label for="importWorkOrderId" class="form-label">Work Order ID</label>
                                        <input type="text" id="importWorkOrderId" class="form-control" readonly placeholder="From SDF data">
                                        <small class="form-text text-muted">Microvellum ID (read-only)</small>
                                    </div>
                                    <div class="col-md-3">
                                        <label for="importDate" class="form-label">Import Date</label>
                                        <input type="text" id="importDate" class="form-control" readonly>
                                        <small class="form-text text-muted">Current timestamp</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Actions -->
                    <div class="import-actions">
                        <div class="row g-3 align-items-center">
                            <div class="col-md-4">
                                <div class="d-flex gap-2 flex-wrap">
                                    <button type="button" id="selectAllBtn" class="btn btn-outline-success btn-sm">
                                        <i class="fas fa-check-double me-1"></i>Select All
                                    </button>
                                    <button type="button" id="clearAllBtn" class="btn btn-outline-danger btn-sm">
                                        <i class="fas fa-times me-1"></i>Clear All
                                    </button>
                                    <button type="button" id="expandAllBtn" class="btn btn-outline-primary btn-sm">
                                        <i class="fas fa-expand-alt me-1"></i>Expand All
                                    </button>
                                    <button type="button" id="collapseAllBtn" class="btn btn-outline-secondary btn-sm">
                                        <i class="fas fa-compress-alt me-1"></i>Collapse All
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <input type="text" id="searchInput" class="form-control form-control-sm" 
                                       placeholder="Search items...">
                            </div>
                            <div class="col-md-4">
                                <button type="button" id="downloadCsvBtn" class="btn btn-outline-info btn-sm">
                                    <i class="fas fa-download me-1"></i>Export Raw Data CSV
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Selection Warnings -->
                    <div id="selectionWarnings" class="selection-warnings d-none">
                        <h6><i class="fas fa-exclamation-triangle me-2"></i>Selection Issues</h6>
                        <ul id="warningsList" class="mb-0">
                        </ul>
                    </div>

                    <!-- Unified Tree Container -->
                    <div id="workOrderTree" class="unified-tree-container">
                        <!-- Tree content will be rendered here by the unified component -->
                    </div>

                    <div class="d-grid gap-2">
                        <button type="button" id="confirmImportBtn" class="btn btn-success btn-lg">
                            <i class="fas fa-check me-2"></i>Confirm Import
                        </button>
                        <button type="button" id="startOverBtn" class="btn btn-outline-secondary">
                            <i class="fas fa-redo me-2"></i>Start Over
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.0/signalr.min.js"></script>
    <script>
        // Global variables
        let currentSessionId = null;
        let signalRConnection = null;
        let importData = null;
        let selectionState = new Map(); // Track selection state by node ID
        let selectionCounts = {
            products: 0,
            parts: 0,
            subassemblies: 0,
            hardware: 0,
            nestSheets: 0
        };
        
        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('sdfFile');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        // workOrderNameInput removed - name will be extracted from SDF data
        const startImportBtn = document.getElementById('startImportBtn');
        
        // Steps
        const uploadStep = document.getElementById('uploadStep');
        const progressStep = document.getElementById('progressStep');
        const previewStep = document.getElementById('previewStep');
        
        // Progress elements
        const progressBar = document.getElementById('progressBar');
        const currentStage = document.getElementById('currentStage');
        const timeRemaining = document.getElementById('timeRemaining');
        const cancelImportBtn = document.getElementById('cancelImportBtn');
        
        // Preview elements
        const finalWorkOrderName = document.getElementById('finalWorkOrderName');
        const totalProducts = document.getElementById('totalProducts');
        const totalParts = document.getElementById('totalParts');
        const totalSubassemblies = document.getElementById('totalSubassemblies');
        const totalHardware = document.getElementById('totalHardware');
        const totalNestSheets = document.getElementById('totalNestSheets');
        const selectedProducts = document.getElementById('selectedProducts');
        const selectedParts = document.getElementById('selectedParts');
        const selectedSubassemblies = document.getElementById('selectedSubassemblies');
        const selectedHardware = document.getElementById('selectedHardware');
        const selectedNestSheets = document.getElementById('selectedNestSheets');
        const treeView = document.getElementById('treeView');
        const searchFilter = document.getElementById('searchFilter');
        const selectAllProductsBtn = document.getElementById('selectAllProductsBtn');
        const selectAllNestSheetsBtn = document.getElementById('selectAllNestSheetsBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const expandAllBtn = document.getElementById('expandAllBtn');
        const collapseAllBtn = document.getElementById('collapseAllBtn');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const confirmImportBtn = document.getElementById('confirmImportBtn');
        const startOverBtn = document.getElementById('startOverBtn');
        const selectionSummary = document.getElementById('selectionSummary');
        const selectionWarnings = document.getElementById('selectionWarnings');
        const warningsList = document.getElementById('warningsList');
        const summaryProducts = document.getElementById('summaryProducts');
        const summaryParts = document.getElementById('summaryParts');
        const summarySubassemblies = document.getElementById('summarySubassemblies');
        const summaryHardware = document.getElementById('summaryHardware');
        const summaryNestSheets = document.getElementById('summaryNestSheets');

        // Initialize SignalR connection
        async function initializeSignalR() {
            signalRConnection = new signalR.HubConnectionBuilder()
                .withUrl("/importProgress")
                .build();

            signalRConnection.on("ImportProgress", function (data) {
                updateProgress(data.percentage, data.stage, data.estimatedTimeRemaining);
            });

            signalRConnection.on("ImportComplete", function (data) {
                handleImportComplete(data);
            });

            signalRConnection.on("ImportError", function (data) {
                handleImportError(data.error);
            });

            try {
                await signalRConnection.start();
                console.log("SignalR connected");
            } catch (err) {
                console.error("SignalR connection failed: " + err);
            }
        }

        // File upload handlers
        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-primary');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-primary');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-primary');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.name.toLowerCase().endsWith('.sdf')) {
                    fileInput.files = files;
                    showFileInfo(file);
                } else {
                    alert('Please select an SDF file.');
                }
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                showFileInfo(file);
            }
        });

        function showFileInfo(file) {
            fileName.textContent = file.name + ' (' + formatBytes(file.size) + ')';
            fileInfo.classList.remove('d-none');
            checkFormValid();
        }

        function checkFormValid() {
            const fileSelected = fileInput.files.length > 0;
            startImportBtn.disabled = !fileSelected;
        }

        // Import process
        startImportBtn.addEventListener('click', async () => {
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file.');
                return;
            }

            try {
                // Upload file
                const formData = new FormData();
                formData.append('file', file);

                const uploadResponse = await fetch('/Import/UploadFile', {
                    method: 'POST',
                    body: formData
                });

                if (!uploadResponse.ok) {
                    const error = await uploadResponse.json();
                    throw new Error(error.error || 'Upload failed');
                }

                const uploadResult = await uploadResponse.json();
                currentSessionId = uploadResult.sessionId;

                // Join SignalR group
                if (signalRConnection) {
                    await signalRConnection.invoke("JoinImportGroup", currentSessionId);
                }

                // Start import (work order name will be extracted from SDF data)
                const importResponse = await fetch('/Import/StartImport', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sessionId: currentSessionId,
                        workOrderName: null // Will be extracted from SDF data
                    })
                });

                if (!importResponse.ok) {
                    const error = await importResponse.json();
                    throw new Error(error.error || 'Import failed to start');
                }

                // Switch to progress view
                showProgressStep();

            } catch (error) {
                alert('Error starting import: ' + error.message);
                console.error('Import error:', error);
            }
        });

        // Progress tracking
        function updateProgress(percentage, stage, estimatedTimeRemaining) {
            progressBar.style.width = percentage + '%';
            progressBar.textContent = percentage + '%';
            progressBar.setAttribute('aria-valuenow', percentage);
            
            currentStage.textContent = stage;
            
            if (estimatedTimeRemaining > 0) {
                const minutes = Math.floor(estimatedTimeRemaining / 60);
                const seconds = Math.floor(estimatedTimeRemaining % 60);
                timeRemaining.textContent = `${minutes}m ${seconds}s`;
            } else {
                timeRemaining.textContent = 'Completing...';
            }
        }

        async function handleImportComplete(data) {
            try {
                // Fetch the import data
                const response = await fetch(`/Import/GetImportData?sessionId=${currentSessionId}`);
                if (response.ok) {
                    importData = await response.json();
                    showPreviewStep();
                } else {
                    throw new Error('Failed to load import data');
                }
            } catch (error) {
                alert('Error loading import data: ' + error.message);
            }
        }

        function handleImportError(error) {
            alert('Import failed: ' + error);
            showUploadStep();
        }

        // Cancel import
        cancelImportBtn.addEventListener('click', async () => {
            if (confirm('Are you sure you want to cancel the import?')) {
                try {
                    await fetch(`/Import/CancelImport?sessionId=${currentSessionId}`, {
                        method: 'DELETE'
                    });
                    showUploadStep();
                } catch (error) {
                    console.error('Cancel error:', error);
                }
            }
        });

        // Step navigation
        function showUploadStep() {
            uploadStep.classList.remove('d-none');
            progressStep.classList.add('d-none');
            previewStep.classList.add('d-none');
        }

        function showProgressStep() {
            uploadStep.classList.add('d-none');
            progressStep.classList.remove('d-none');
            previewStep.classList.add('d-none');
        }

        function showPreviewStep() {
            uploadStep.classList.add('d-none');
            progressStep.classList.add('d-none');
            previewStep.classList.remove('d-none');
            
            if (importData) {
                populatePreview();
                buildTreeView();
            }
        }

        // Preview functionality
        function populatePreview() {
            // Set work order name (extracted from data or use filename as fallback)
            finalWorkOrderName.value = importData.name || 'Imported Work Order';
            
            // Populate unified interface fields
            const importWorkOrderId = document.getElementById('importWorkOrderId');
            const importDate = document.getElementById('importDate');
            
            if (importWorkOrderId) {
                importWorkOrderId.value = importData.id || 'Generated from SDF';
            }
            
            if (importDate) {
                importDate.value = new Date().toLocaleString();
            }
            
            const stats = importData.statistics;
            totalProducts.textContent = stats.totalProducts;
            totalParts.textContent = stats.totalParts;
            totalSubassemblies.textContent = stats.totalSubassemblies;
            totalHardware.textContent = stats.totalHardware;
            totalNestSheets.textContent = stats.totalNestSheets;
        }

        function buildTreeView() {
            treeView.innerHTML = '';
            selectionState.clear(); // Reset selection state
            
            if (!importData.products || importData.products.length === 0) {
                treeView.innerHTML = '<p class="text-muted">No products found in import data.</p>';
                return;
            }

            // Display products directly (no wrapper categories)
            importData.products.forEach(product => {
                const productNode = createProductNode(product, 0);
                treeView.appendChild(productNode);
            });

            // Add standalone hardware if any
            if (importData.hardware && importData.hardware.length > 0) {
                importData.hardware.forEach(hardware => {
                    const hardwareNode = createHardwareNode(hardware, 0);
                    treeView.appendChild(hardwareNode);
                });
            }

            // Add detached products if any
            if (importData.detachedProducts && importData.detachedProducts.length > 0) {
                importData.detachedProducts.forEach(detached => {
                    const detachedNode = createDetachedProductNode(detached, 0);
                    treeView.appendChild(detachedNode);
                });
            }

            // Add nest sheets if any (always auto-selected)
            if (importData.nestSheets && importData.nestSheets.length > 0) {
                const nestSheetsHeader = createTreeNode('ðŸ“„', `Nest Sheets (${importData.nestSheets.length})`, 'nestsheets-header', true, 0);
                treeView.appendChild(nestSheetsHeader);
                
                importData.nestSheets.forEach(nestSheet => {
                    const nestSheetNode = createNestSheetNode(nestSheet, 1);
                    treeView.appendChild(nestSheetNode);
                    
                    // Auto-select all nest sheets and make them non-interactive
                    const nestSheetId = nestSheetNode.dataset.itemId;
                    const nestSheetState = selectionState.get(nestSheetId);
                    if (nestSheetState) {
                        nestSheetState.selected = true;
                        // Disable the checkbox since nest sheets are always imported
                        const checkbox = nestSheetNode.querySelector('.tree-checkbox');
                        if (checkbox) {
                            checkbox.checked = true;
                            checkbox.disabled = true;
                            checkbox.title = "Nest sheets are always imported";
                        }
                    }
                });
            }

            // Initialize selection counts and summary
            updateSelectionCounts();
            updateSelectionSummary();
            validateSelection();
        }

        function createTreeNode(icon, text, type, expanded = false, level = 0, itemId = null, itemData = null) {
            const node = document.createElement('div');
            node.className = `tree-node level-${level}`;
            node.dataset.type = type;
            node.dataset.itemId = itemId || `${type}-${Math.random().toString(36).substr(2, 9)}`;
            
            const hasChildren = type === 'work-order' || type === 'products-header' || type === 'hardware-header' || 
                               type === 'detached-header' || type === 'nestsheets-header' || type === 'product' || type === 'subassembly';
            
            const nodeId = node.dataset.itemId;
            
            // Initialize selection state
            if (!selectionState.has(nodeId)) {
                selectionState.set(nodeId, {
                    selected: true, // Default to selected for backward compatibility
                    type: type,
                    itemData: itemData,
                    parentId: null,
                    childIds: []
                });
            }
            
            node.innerHTML = `
                <div class="d-flex align-items-center">
                    ${hasChildren ? 
                        `<span class="tree-toggle me-2" data-expanded="${expanded}" style="width: 16px; display: inline-block;">
                            <i class="fas fa-${expanded ? 'chevron-down' : 'chevron-right'}" style="font-size: 12px;"></i>
                        </span>` : 
                        '<span class="me-2" style="width: 16px; display: inline-block;"></span>'
                    }
                    <input type="checkbox" class="tree-checkbox form-check-input me-2" checked data-node-id="${nodeId}">
                    <span class="me-2">${icon}</span>
                    <span class="flex-grow-1">${text}</span>
                </div>
            `;

            // Handle expand/collapse
            if (hasChildren) {
                const toggle = node.querySelector('.tree-toggle');
                if (toggle) {
                    toggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isExpanded = toggle.dataset.expanded === 'true';
                        toggle.dataset.expanded = !isExpanded;
                        const icon = toggle.querySelector('i');
                        if (icon) {
                            icon.className = `fas fa-chevron-${!isExpanded ? 'down' : 'right'}`;
                        }
                        
                        const content = node.querySelector('.tree-content');
                        if (content) {
                            content.style.display = !isExpanded ? 'block' : 'none';
                        }
                    });
                }
            }

            // Handle checkbox changes
            const checkbox = node.querySelector('.tree-checkbox');
            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    handleNodeSelection(nodeId, checkbox.checked);
                });
            }

            return node;
        }

        function createProductNode(product, level = 0) {
            // If ProductNumber and Name are the same (no separate product name), show just ItemNumber - Qty
            // Otherwise show ItemNumber - ProductName - Qty
            const displayName = (product.productNumber && product.productNumber !== product.name) ? 
                `${product.productNumber} - ${product.name} - Qty. ${product.quantity}` :
                `${product.productNumber || product.name} - Qty. ${product.quantity}`;
            
            const productNode = createTreeNode('ðŸšª', displayName, 'product', false, level, product.id, product);
            const productId = productNode.dataset.itemId;
            
            const content = document.createElement('div');
            content.className = 'tree-content';
            content.style.display = 'none';
            productNode.appendChild(content);

            // Track child relationships
            const childIds = [];

            // Add parts
            product.parts.forEach(part => {
                const partNode = createPartNode(part, level + 1, productId);
                content.appendChild(partNode);
                childIds.push(partNode.dataset.itemId);
            });

            // Add subassemblies
            product.subassemblies.forEach(subassembly => {
                const subassemblyNode = createSubassemblyNode(subassembly, level + 1, productId);
                content.appendChild(subassemblyNode);
                childIds.push(subassemblyNode.dataset.itemId);
            });

            // Add hardware
            product.hardware.forEach(hardware => {
                const hardwareNode = createHardwareNode(hardware, level + 1, productId);
                content.appendChild(hardwareNode);
                childIds.push(hardwareNode.dataset.itemId);
            });

            // Update parent-child relationships
            const productState = selectionState.get(productId);
            if (productState) {
                productState.childIds = childIds;
                childIds.forEach(childId => {
                    const childState = selectionState.get(childId);
                    if (childState) {
                        childState.parentId = productId;
                    }
                });
            }

            return productNode;
        }

        function createPartNode(part, level = 3, parentId = null) {
            return createTreeNode('ðŸ“„', 
                `${part.id} - ${part.name} (Qty: ${part.quantity}, ${part.width}mmÃ—${part.height}mmÃ—${part.thickness}mm, ${part.material})`, 
                'part', false, level, part.id, part);
        }

        function createSubassemblyNode(subassembly, level = 3, parentId = null) {
            const subassemblyNode = createTreeNode('ðŸ“', 
                `${subassembly.id} - ${subassembly.name} (Qty: ${subassembly.quantity})`, 
                'subassembly', false, level, subassembly.id, subassembly);
            const subassemblyId = subassemblyNode.dataset.itemId;
            
            const content = document.createElement('div');
            content.className = 'tree-content';
            content.style.display = 'none';
            subassemblyNode.appendChild(content);

            // Track child relationships
            const childIds = [];

            // Add parts
            subassembly.parts.forEach(part => {
                const partNode = createPartNode(part, level + 1, subassemblyId);
                content.appendChild(partNode);
                childIds.push(partNode.dataset.itemId);
            });

            // Add nested subassemblies
            subassembly.nestedSubassemblies.forEach(nested => {
                const nestedNode = createSubassemblyNode(nested, level + 1, subassemblyId);
                content.appendChild(nestedNode);
                childIds.push(nestedNode.dataset.itemId);
            });

            // Add hardware
            subassembly.hardware.forEach(hardware => {
                const hardwareNode = createHardwareNode(hardware, level + 1, subassemblyId);
                content.appendChild(hardwareNode);
                childIds.push(hardwareNode.dataset.itemId);
            });

            // Update parent-child relationships
            const subassemblyState = selectionState.get(subassemblyId);
            if (subassemblyState) {
                subassemblyState.childIds = childIds;
                childIds.forEach(childId => {
                    const childState = selectionState.get(childId);
                    if (childState) {
                        childState.parentId = subassemblyId;
                    }
                });
            }

            return subassemblyNode;
        }

        function createHardwareNode(hardware, level = 3, parentId = null) {
            return createTreeNode('ðŸ”§', 
                `${hardware.id} - ${hardware.name} (Qty: ${hardware.quantity})`, 
                'hardware', false, level, hardware.id, hardware);
        }

        function createDetachedProductNode(detached, level = 2) {
            return createTreeNode('ðŸ“„', 
                `${detached.id} - ${detached.name} (Qty: ${detached.quantity}, ${detached.width}mmÃ—${detached.height}mmÃ—${detached.thickness}mm)`, 
                'detached', false, level, detached.id, detached);
        }

        function createNestSheetNode(nestSheet, level = 1) {
            return createTreeNode('ðŸ“‹', 
                `${nestSheet.name} (${nestSheet.material || 'Unknown Material'}, ${nestSheet.length}mmÃ—${nestSheet.width}mmÃ—${nestSheet.thickness}mm)`, 
                'nestsheet', false, level, nestSheet.id, nestSheet);
        }

        // Selection Management Functions
        function handleNodeSelection(nodeId, isSelected) {
            const nodeState = selectionState.get(nodeId);
            if (!nodeState) return;

            // Update selection state
            nodeState.selected = isSelected;

            // Handle parent-child dependencies
            if (isSelected) {
                // When selecting a node, auto-select all children
                selectAllChildren(nodeId);
                // Update parent state (might become partially selected)
                updateParentState(nodeState.parentId);
            } else {
                // When deselecting a node, deselect all children
                deselectAllChildren(nodeId);
                // Update parent state
                updateParentState(nodeState.parentId);
            }

            // Update UI
            updateNodeVisualState(nodeId);
            updateSelectionCounts();
            updateSelectionSummary();
            validateSelection();
        }

        function selectAllChildren(parentId) {
            const parentState = selectionState.get(parentId);
            if (!parentState) return;

            parentState.childIds.forEach(childId => {
                const childState = selectionState.get(childId);
                if (childState && !childState.selected) {
                    childState.selected = true;
                    updateNodeVisualState(childId);
                    selectAllChildren(childId); // Recursively select grandchildren
                }
            });
        }

        function deselectAllChildren(parentId) {
            const parentState = selectionState.get(parentId);
            if (!parentState) return;

            parentState.childIds.forEach(childId => {
                const childState = selectionState.get(childId);
                if (childState && childState.selected) {
                    childState.selected = false;
                    updateNodeVisualState(childId);
                    deselectAllChildren(childId); // Recursively deselect grandchildren
                }
            });
        }

        function updateParentState(parentId) {
            if (!parentId) return;

            const parentState = selectionState.get(parentId);
            if (!parentState) return;

            // Check children selection states
            const selectedChildren = parentState.childIds.filter(childId => {
                const childState = selectionState.get(childId);
                return childState && childState.selected;
            });

            const allSelected = selectedChildren.length === parentState.childIds.length;
            const noneSelected = selectedChildren.length === 0;

            if (allSelected) {
                parentState.selected = true;
                parentState.partiallySelected = false;
            } else if (noneSelected) {
                parentState.selected = false;
                parentState.partiallySelected = false;
            } else {
                parentState.selected = false;
                parentState.partiallySelected = true;
            }

            updateNodeVisualState(parentId);
            updateParentState(parentState.parentId); // Recursively update grandparents
        }

        function updateNodeVisualState(nodeId) {
            const nodeState = selectionState.get(nodeId);
            if (!nodeState) return;

            const nodeElement = document.querySelector(`[data-item-id="${nodeId}"]`);
            if (!nodeElement) return;

            const checkbox = nodeElement.querySelector('.tree-checkbox');
            if (checkbox) {
                checkbox.checked = nodeState.selected;
                checkbox.indeterminate = nodeState.partiallySelected || false;
                checkbox.classList.toggle('indeterminate', nodeState.partiallySelected || false);
            }

            // Update visual styling
            nodeElement.classList.remove('selected', 'partially-selected');
            if (nodeState.selected) {
                nodeElement.classList.add('selected');
            } else if (nodeState.partiallySelected) {
                nodeElement.classList.add('partially-selected');
            }
        }

        function updateSelectionCounts() {
            // Reset counts
            selectionCounts = {
                products: 0,
                parts: 0,
                subassemblies: 0,
                hardware: 0,
                nestSheets: 0
            };

            // Count selected items by type
            selectionState.forEach(state => {
                if (state.selected) {
                    switch (state.type) {
                        case 'product':
                            selectionCounts.products++;
                            break;
                        case 'part':
                            selectionCounts.parts++;
                            break;
                        case 'subassembly':
                            selectionCounts.subassemblies++;
                            break;
                        case 'hardware':
                            selectionCounts.hardware++;
                            break;
                        case 'nestsheet':
                            selectionCounts.nestSheets++;
                            break;
                    }
                }
            });

            // Update UI
            selectedProducts.textContent = selectionCounts.products;
            selectedParts.textContent = selectionCounts.parts;
            selectedSubassemblies.textContent = selectionCounts.subassemblies;
            selectedHardware.textContent = selectionCounts.hardware;
            selectedNestSheets.textContent = selectionCounts.nestSheets;
        }

        function updateSelectionSummary() {
            const hasSelection = selectionCounts.products > 0 || selectionCounts.parts > 0 || 
                               selectionCounts.subassemblies > 0 || selectionCounts.hardware > 0 || selectionCounts.nestSheets > 0;

            if (hasSelection) {
                selectionSummary.classList.remove('d-none');
                summaryProducts.textContent = selectionCounts.products;
                summaryParts.textContent = selectionCounts.parts;
                summarySubassemblies.textContent = selectionCounts.subassemblies;
                summaryHardware.textContent = selectionCounts.hardware;
                summaryNestSheets.textContent = selectionCounts.nestSheets;
            } else {
                selectionSummary.classList.add('d-none');
            }
        }

        function validateSelection() {
            const warnings = [];
            let hasValidSelection = false;

            // Check for products with incomplete selections
            selectionState.forEach((state, nodeId) => {
                if (state.type === 'product' && state.partiallySelected) {
                    warnings.push(`Product "${state.itemData?.productNumber || nodeId}" has incomplete selection. Select all parts or deselect the product.`);
                }
                if (state.selected && (state.type === 'product' || state.type === 'hardware' || state.type === 'detached')) {
                    hasValidSelection = true;
                }
            });

            // Check for orphaned parts/subassemblies (selected without parent)
            selectionState.forEach((state, nodeId) => {
                if (state.selected && (state.type === 'part' || state.type === 'subassembly') && state.parentId) {
                    const parentState = selectionState.get(state.parentId);
                    if (parentState && !parentState.selected && !parentState.partiallySelected) {
                        warnings.push(`${state.type === 'part' ? 'Part' : 'Subassembly'} "${state.itemData?.name || nodeId}" is selected but its parent is not. Select the parent product first.`);
                    }
                }
            });

            // Update warnings UI
            if (warnings.length > 0) {
                selectionWarnings.classList.remove('d-none');
                warningsList.innerHTML = warnings.map(warning => `<li>${warning}</li>`).join('');
            } else {
                selectionWarnings.classList.add('d-none');
            }

            // Enable/disable confirm button
            const isValid = hasValidSelection && warnings.length === 0;
            confirmImportBtn.disabled = !isValid;
            
            return isValid;
        }

        // Tree view controls
        selectAllProductsBtn.addEventListener('click', () => {
            // Select all products (which will auto-select their children)
            selectionState.forEach((state, nodeId) => {
                if (state.type === 'product' || state.type === 'hardware' || state.type === 'detached') {
                    if (!state.selected) {
                        state.selected = true;
                        updateNodeVisualState(nodeId);
                        selectAllChildren(nodeId);
                    }
                }
            });
            updateSelectionCounts();
            updateSelectionSummary();
            validateSelection();
        });

        selectAllNestSheetsBtn.addEventListener('click', () => {
            // Select all nest sheets
            selectionState.forEach((state, nodeId) => {
                if (state.type === 'nestsheet') {
                    if (!state.selected) {
                        state.selected = true;
                        updateNodeVisualState(nodeId);
                        selectAllChildren(nodeId);
                    }
                }
            });
            updateSelectionCounts();
            updateSelectionSummary();
            validateSelection();
        });

        clearAllBtn.addEventListener('click', () => {
            // Deselect everything
            selectionState.forEach((state, nodeId) => {
                if (state.selected) {
                    state.selected = false;
                    state.partiallySelected = false;
                    updateNodeVisualState(nodeId);
                }
            });
            updateSelectionCounts();
            updateSelectionSummary();
            validateSelection();
        });

        expandAllBtn.addEventListener('click', () => {
            const toggles = treeView.querySelectorAll('.tree-toggle');
            toggles.forEach(toggle => {
                toggle.dataset.expanded = 'true';
                toggle.querySelector('i').className = 'fas fa-chevron-down';
                const content = toggle.closest('.tree-node').querySelector('.tree-content');
                if (content) content.style.display = 'block';
            });
        });

        collapseAllBtn.addEventListener('click', () => {
            const toggles = treeView.querySelectorAll('.tree-toggle');
            toggles.forEach(toggle => {
                toggle.dataset.expanded = 'false';
                toggle.querySelector('i').className = 'fas fa-chevron-right';
                const content = toggle.closest('.tree-node').querySelector('.tree-content');
                if (content) content.style.display = 'none';
            });
        });

        // Search functionality
        searchFilter.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const nodes = treeView.querySelectorAll('.tree-node');
            
            nodes.forEach(node => {
                const text = node.textContent.toLowerCase();
                const shouldShow = searchTerm === '' || text.includes(searchTerm);
                node.style.display = shouldShow ? 'block' : 'none';
            });
        });

        // CSV download functionality
        downloadCsvBtn.addEventListener('click', () => {
            if (currentSessionId) {
                window.location.href = `/Import/ExportRawDataCsv?sessionId=${currentSessionId}`;
            } else {
                alert('No import session available for CSV export.');
            }
        });

        // Confirm import
        confirmImportBtn.addEventListener('click', async () => {
            if (!validateSelection()) {
                alert('Please fix the selection issues before proceeding.');
                return;
            }

            if (!currentSessionId) {
                alert('No import session available.');
                return;
            }

            const workOrderName = finalWorkOrderName.value.trim();
            if (!workOrderName) {
                alert('Please enter a work order name.');
                finalWorkOrderName.focus();
                return;
            }

            try {
                // Disable button during processing
                confirmImportBtn.disabled = true;
                confirmImportBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processing...';

                // Prepare selection data
                const selectedItemIds = [];
                const selectionDetails = {};

                selectionState.forEach((state, nodeId) => {
                    // Only include actual items, not header/category nodes
                    const isHeaderNode = state.type.includes('-header') || 
                                       state.type === 'work-order' || 
                                       state.type === 'products-header' || 
                                       state.type === 'hardware-header' || 
                                       state.type === 'detached-header' ||
                                       state.type === 'nestsheets-header';
                    
                    if (state.selected && !isHeaderNode) {
                        selectedItemIds.push(nodeId);
                    }
                    
                    selectionDetails[nodeId] = {
                        itemId: nodeId,
                        itemType: state.type,
                        selected: state.selected,
                        parentId: state.parentId,
                        childIds: state.childIds || []
                    };
                });

                const selectionRequest = {
                    sessionId: currentSessionId,
                    workOrderName: workOrderName,
                    selectedItemIds: selectedItemIds,
                    selectionDetails: selectionDetails
                };

                console.log("Sending selection request with", selectedItemIds.length, "selected items");

                const response = await fetch('/Import/ProcessSelectedItems', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(selectionRequest)
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    // Show success message with database confirmation
                    alert(`Work Order successfully imported to database!\n\n` +
                          `Saved:\n` +
                          `â€¢ ${result.statistics.convertedProducts} Products\n` +
                          `â€¢ ${result.statistics.convertedParts} Parts\n` +
                          `â€¢ ${result.statistics.convertedSubassemblies} Subassemblies\n` +
                          `â€¢ ${result.statistics.convertedHardware} Hardware\n` +
                          `â€¢ ${result.statistics.convertedNestSheets} Nest Sheets\n\n` +
                          `Work Order ID: ${result.workOrderId}\n` +
                          `Work Order Name: ${workOrderName}\n\n` +
                          `The work order is now available in the system.`);

                    // Redirect to work orders list after successful import
                    console.log('Import completed successfully:', result);
                    setTimeout(() => {
                        window.location.href = '/Admin';
                    }, 2000);
                    
                } else {
                    // Show error details
                    let errorMessage = result.error || 'Unknown error occurred';
                    if (result.details && result.details.length > 0) {
                        errorMessage += '\n\nDetails:\nâ€¢ ' + result.details.join('\nâ€¢ ');
                    }
                    if (result.warnings && result.warnings.length > 0) {
                        errorMessage += '\n\nWarnings:\nâ€¢ ' + result.warnings.join('\nâ€¢ ');
                    }
                    alert('Import processing failed:\n\n' + errorMessage);
                }

            } catch (error) {
                console.error('Import processing error:', error);
                alert('Error processing import: ' + error.message);
            } finally {
                // Re-enable button
                confirmImportBtn.disabled = false;
                confirmImportBtn.innerHTML = '<i class="fas fa-check me-2"></i>Confirm Import';
            }
        });

        startOverBtn.addEventListener('click', () => {
            showUploadStep();
            // Reset form
            fileInput.value = '';
            fileInfo.classList.add('d-none');
            checkFormValid();
        });

        // Utility functions
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeSignalR();
        });
    </script>
}